#!/bin/zsh

# fontutil
#   © 2025 YOCKOW.
#     Licensed under MIT License.
#     See "LICENSE.txt" for more information.

set -euo pipefail
set -o extendedglob


local -r commandName="$0"
local -r -A subcommands=(
  [--help]="View help message."
  [authors]="View the authors of the font."
  [copyright]="View the copyright information of the font."
  [family-name]="View the family name(s) of the font(s)."
  [fond-name]="View the fond name of the font."
  [full-name]="View the full name of the font."
  [hash]="View the file hash for the font. (Internal Use)"
  [postscript-name]="View the PostScript name of the font."
  [publishers]="View the publishers of the font."
  [style-name]="View the style name of the font."
  [version]="View the version of the font."
)
local -r -A subcommandAliases=(
  [author]=authors
  [family]=family-name
  [publisher]=publishers
)
local -r -a supportedContentTypes=(
  "public.opentype-font"
  "public.truetype-ttf-font"
)


##### Miscellaneous Functions #####

function printError() {
  local -r message="$1"
  printf '\033[31merror:\033[m %s\n' "$message" 1>&2
}

function printWarning() {
  local -r message="$1"
  printf '\033[33mwarning:\033[m %s\n' "$message" 1>&2
}

function printInfo() {
  local -r message="$1"
  printf '\033[2minfo:\033[m %s\n' "$message" 1>&2
}

function printHelp() {
  {
    echo "Usage: $commandName <subcommand> [options...]"
    echo
    echo "Subcommands:"
    
    local -r -a subcommandNames=("${(@k)subcommands}")
    local subcommandName
    for subcommandName in ${(o)subcommandNames}; do
      if [[ "$subcommandName" == "--help" ]]; then
        continue
      fi
      printf "%16s: %s\n" "$subcommandName" "${subcommands[$subcommandName]}"
    done
    echo 

    echo "Subcommand Aliases:"
    local -r -a subcommandAliasNames=(${(@k)subcommandAliases})
    local aliasName
    for aliasName in ${(o)subcommandAliasNames}; do
      printf "%16s: %s\n" "$aliasName" "Alias of '${subcommandAliases[$aliasName]}'"
    done
  } 1>&2
}

function assertionFailed() {
  local -r message="$1"
  local -r lineNumber="${2:-0}"
  echo "❗ Assertion failed (bug): line ${lineNumber}: $message" 1>&2
  exit 1
}

function isTrue() {
  local -r value="$1"
  if [[ "${(L)value}" == "true" ]]; then
    return 0
  else
    return 1
  fi
}

local isVerbose="false"
function verbosePrint() {
  local -r message="$1"
  if isTrue $isVerbose; then
    printInfo "$message"
  fi
}

local -A __cache_isSupportedFile=()
function isSupportedFile() {
  local -r filePath="$1"

  function __isSupportedFile() {
    if [[ ! -f "$filePath" ]]; then
      return 1
    fi

    local -r fileContentType=$(mdls -raw -nullMarker "" -name kMDItemContentType "$filePath")
    if (( $supportedContentTypes[(Ie)$fileContentType] )); then
      return 0
    fi
    return 1
  }

  if [[ -n "${__cache_isSupportedFile[(i)$filePath]}" ]]; then
    if isTrue "${__cache_isSupportedFile[$filePath]}"; then
      return 0
    else
      return 1
    fi
  fi

  if __isSupportedFile; then
    __cache_isSupportedFile[$filePath]="true"
    return 0
  else
    __cache_isSupportedFile[$filePath]="false"
    return 1
  fi
}

function allFiles() {
  local -A parsedArguments=()
  zparseopts -D -E -A parsedArguments -- -validate
  local -r validate=$(
    if [[ -n "${parsedArguments[(i)--validate]}" ]]; then
      echo "true"
    else
      echo "false"
    fi
  )

  local -r -a givenFilePaths=($@)
  local filePath
  for filePath in $filePaths; do
    if [[ -f "$filePath" ]]; then
      if isTrue $validate && ! isSupportedFile "$filePath"; then
        printWarning "Unsupported file at ${filePath}."
        continue
      fi
      echo $filePath
    elif [[ -d "$filePath" ]]; then
      local subFilePaths=(${filePath%%/}/**/*(-.))
      local subFilePath
      for subFilePath in $subFilePaths; do
        local fontPathCandidate=$(
          if [[ -f "$subFilePath" ]]; then
            echo $subFilePath
          elif [[ -L "$subFilePath" ]]; then
            readlink -f "$subFilePath" 
          fi
        )
        if isTrue $validate && ! isSupportedFile "$fontPathCandidate"; then
          printWarning "Unsupported file at ${fontPathCandidate}."
          continue
        fi
        echo $fontPathCandidate
      done
    else
      printWarning "File not found at ${filePath}."
    fi
  done
}

function decodeMDString() {
  local rawString="${1-}"
  if [[ "$rawString" =~ '^".+"$' ]]; then
    rawString="${rawString//\\U/\\u}"
  else
    rawString="${(q)rawString}"
  fi
  eval "echo $rawString"
}

function decodedMDArrayForNameAtPath() {
  [[ $#@ -eq 2 ]] || assertionFailed "decodedMDArrayForNameAtPath() requires exactly two arguments." ${(%):-%I}

  local -r mdName="$1"
  local -r filePath="$2"
  local -r mdArrayLinesString=$(mdls -raw -nullMarker "" -name "$mdName" "$filePath")
  local -r -a mdArrayLines=(${(f)mdArrayLinesString})
  local -r numberOfMDArrayLines=$(( $#mdArrayLines + 0 ))
  local mdArrayLine
  local ii
  for ii in {1..$numberOfMDArrayLines}; do
    mdArrayLine="${${mdArrayLines[$ii]##[[:space:]]##}%%[[:space:]]##}"
    if [[ -z "$mdArrayLine" ]]; then
      continue
    fi
    if [[ $ii -eq 1 ]] && [[ "$mdArrayLine" == "(" ]]; then
      continue
    fi
    if [[ $ii -eq $numberOfMDArrayLines ]] && [[ "$mdArrayLine" == ")" ]]; then
      continue
    fi
    if [[ $ii -gt 1 ]]; then
      mdArrayLine=${mdArrayLine%%,}
    fi
    printf '%s\n' "$(decodeMDString "$mdArrayLine")"
  done
}

local -A __cache_printItemsForAttributeAtPath=()
function printItemsForAttributeAtPath() {
  local -A parsedArguments=()
  zparseopts -D -E -A parsedArguments -- -with-filename
  local -r withFilename=$(
    if [[ -n "${parsedArguments[(i)--with-filename]}" ]]; then
      echo "true"
    else
      echo "false"
    fi
  )

  [[ $#@ -eq 2 ]] || assertionFailed "printItemsForAttributeAtPath() requires exactly one attribute name and one file path." ${(%):-%I}

  local -r attributeName="$1"
  local -r filePath="$2"
  [[ -f "$filePath" ]] && isSupportedFile "$filePath" \
    || assertionFailed "printItemsForAttributeAtPath() requires a valid file path." ${(%):-%I}

  function __getFontAttributeItemsString() {
    local -r cacheKey="${filePath}:${attributeName}"
    if [[ -n "${__cache_printItemsForAttributeAtPath[(i)$cacheKey]}" ]]; then
      echo "${__cache_printItemsForAttributeAtPath[$cacheKey]}"
      return 0
    fi

    local -r parsedItems=$(decodedMDArrayForNameAtPath "$attributeName" "$filePath")
    __cache_printItemsForAttributeAtPath[$cacheKey]="$parsedItems"
    echo "$parsedItems"
  }

  if isTrue $withFilename; then
    echo "${filePath}:"
  fi
  local -r fontAttributeString=$(__getFontAttributeItemsString)
  local fontAttributeItem  
  for fontAttributeItem in ${(f)fontAttributeString}; do
    if isTrue $withFilename; then
      printf '  %s\n' "$fontAttributeItem"
    else
      printf '%s\n' "$fontAttributeItem"
    fi
  done
}

##### SUBCOMMANDS #####

function fontutil---help() {
  printHelp
  return 0
}

function __fontutil-attributes-for-files() {
  local -A parsedArguments=()
  zparseopts -D -E -A parsedArguments -- -help
  local -r attributeName="$1"; shift
  local -r -a filePaths=($@)

  function __printAttributesForFilesHelp() {
    {
      echo "${subcommands[$subcommandName]:-${subcommands[$subcommandAliases[$subcommandName]]}}"
      echo "  Usage: $commandName $subcommandName FILE..."
    } 1>&2
  }

  if [[ -n "${parsedArguments[(i)--help]}" ]]; then
    __printAttributesForFilesHelp
    return 0
  fi

  if [[ $#filePaths -lt 1 ]]; then
    printError "No file specified."
    __printAttributesForFilesHelp
    return 1
  fi

  local -r expandedAllFilePathsString=$(allFiles --validate $filePaths)
  local -r -a expandedAllFilePaths=(${(f)expandedAllFilePathsString})
  local fontFilePath
  for fontFilePath in $expandedAllFilePaths; do
    if [[ $#expandedAllFilePaths -gt 1 ]]; then
      printItemsForAttributeAtPath "$attributeName" --with-filename "$fontFilePath"
      printf '\n'
    else 
      printItemsForAttributeAtPath "$attributeName" "$fontFilePath"
    fi
  done
}

function fontutil-authors() {
  __fontutil-attributes-for-files kMDItemAuthors $@
}

function fontutil-copyright() {
  __fontutil-attributes-for-files kMDItemCopyright $@
}

function fontutil-family() {
  __fontutil-attributes-for-files com_apple_ats_name_family $@
}

function fontutil-family-name() {
  fontutil-family $@
}

function fontutil-fond-name() {
  __fontutil-attributes-for-files com_apple_ats_name_fond $@
}

function fontutil-full-name() {
  __fontutil-attributes-for-files com_apple_ats_name_full $@
}

function fontutil-hash() {
  function __hashOfFile() {
    [[ $#@ -eq 1 ]] || assertionFailed "__hashOfFile() requires exactly one file path." ${(%):-%I}
    local -r filePath="$1"
    [[ -f "$filePath" ]] || assertionFailed "File not found at ${filePath}." ${(%):-%I}
    local -r hashed=${(L)$(shasum -a 256 -b "$filePath")[(w)1]}
    [[ "$hashed" =~ ^[0-9a-f]{64}$ ]] || assertionFailed "Unexpected hash value." ${(%):-%I}
    echo $hashed
  }

  local -r -a filePaths=($@)
  if [[ $#filePaths -lt 1 ]]; then
    printError "No file specified."
    return 1
  fi

  local -r -a fontFiles=(${(@f)$(allFiles --validate $filePaths)})
  if [[ $#fontFiles -lt 1 ]]; then
    printError "No supported files."
    return 1
  elif [[ $#fontFiles -eq 1 ]]; then
    __hashOfFile $fontFiles
  else
    local -a hashValues=()
    local fontFile
    for fontFile in $fontFiles; do
      hashValues=($hashValues $(__hashOfFile "$fontFile"))
    done
    hashValues=(${(o)hashValues})
    
    local -r tmpFile="$(mktemp)"
    echo ${(j::)hashValues} | xxd -r -p >"$tmpFile"
    __hashOfFile "$tmpFile"
  fi
}

function fontutil-postscript-name() {
  __fontutil-attributes-for-files com_apple_ats_name_postscript $@
}

function fontutil-publishers() {
  __fontutil-attributes-for-files kMDItemPublishers $@
}

function fontutil-style-name() {
  __fontutil-attributes-for-files com_apple_ats_name_style $@
}

function fontutil-version() {
  __fontutil-attributes-for-files kMDItemVersion $@
}

##### MAIN #####

function _main_() {
  if [[ $#@ -lt 1 ]]; then
    printError "No subcommand specified."
    printHelp
    exit 1
  fi

  local -r subcommandName="$1"
  shift

  local -A commonParsedArguments=()
  zparseopts -D -E -A commonParsedArguments -- v -verbose=v
  if [[ -n "${commonParsedArguments[(i)-v]}" ]]; then
    isVerbose="true"
    verbosePrint "Verbose mode enabled."
  fi

  local -r -a subcommandArguments=($@)
  if [[ -n "$subcommands[(I)$subcommandName]" ]]; then
    "fontutil-$subcommandName" $subcommandArguments
  elif [[ -n "$subcommandAliases[(I)$subcommandName]" ]]; then
    "fontutil-${subcommandAliases[$subcommandName]}" $subcommandArguments
  else
    printError "Unknown subcommand: $subcommandName"
    printHelp
    exit 1
  fi
}
_main_ $@
